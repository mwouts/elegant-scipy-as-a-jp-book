---
title: |-
  Elegant NumPy: The Foundation of Scientific Python
prev_page:
  url: /preface.html
  title: |-
    Preface
next_page:
  url: /ch2.html
  title: |-
    Quantile Normalization with NumPy and SciPy
suffix: .md

comment: "***PROGRAMMATICALLY GENERATED, DO NOT EDIT. SEE ORIGINAL FILES IN /content***"
---

    <main class="jupyter-page">
    <div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Elegant-NumPy:-The-Foundation-of-Scientific-Python">Elegant NumPy: The Foundation of Scientific Python<a class="anchor-link" href="#Elegant-NumPy:-The-Foundation-of-Scientific-Python"> </a></h1><blockquote><p>[NumPy] is everywhere. It is all around us. Even now, in this very room.
You can see it when you look out your window or when you turn on your
television. You can feel it when you go to work... when you go to church...
when you pay your taxes.</p>
<p>— Morpheus, <em>The Matrix</em></p>
</blockquote>
<p>This chapter touches on some statistical functions in SciPy, but more than that, it focuses on exploring the NumPy array, a data structure that underlies almost all numerical scientific computation in Python.
We will see how NumPy array operations enable concise and efficient code when manipulating numerical data.</p>
<p>Our use case is using gene expression data from The Cancer Genome Atlas (TCGA) project to predict mortality in skin cancer patients.
We will be working toward this goal throughout this chapter and the next one, learning about some key SciPy concepts along the way.
Before we can predict mortality, we will need to normalize the expression data using a method called RPKM normalization.
This allows the comparison of measurements between different samples and genes.
(We will unpack what "gene expression" means in just a moment.)</p>
<p>Let's start with a code snippet to tantalize you and introduce the ideas in this chapter.
As we will do in each chapter, we open with a code sample that we believe epitomizes the elegance and power of a particular function from the SciPy ecosystem.
In this case, we want to highlight NumPy's vectorization and broadcasting rules, which allow us to manipulate and reason about data arrays very efficiently.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">rpkm</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">lengths</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate reads per kilobase transcript per million reads.</span>

<span class="sd">    RPKM = (10^9 * C) / (N * L)</span>

<span class="sd">    Where:</span>
<span class="sd">    C = Number of reads mapped to a gene</span>
<span class="sd">    N = Total mapped reads in the experiment</span>
<span class="sd">    L = Exon length in base pairs for a gene</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    counts: array, shape (N_genes, N_samples)</span>
<span class="sd">        RNAseq (or similar) count data where columns are individual samples</span>
<span class="sd">        and rows are genes.</span>
<span class="sd">    lengths: array, shape (N_genes,)</span>
<span class="sd">        Gene lengths in base pairs in the same order</span>
<span class="sd">        as the rows in counts.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    normed : array, shape (N_genes, N_samples)</span>
<span class="sd">        The RPKM normalized counts matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># First, convert counts to float to avoid overflow when multiplying by</span>
    <span class="c1"># 1e9 in the RPKM formula</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sum each column to get total reads per sample</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">lengths</span>

    <span class="n">normed</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="o">*</span> <span class="n">C</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">L</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

    <span class="k">return</span><span class="p">(</span><span class="n">normed</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This example illustrates some of the ways that NumPy arrays can make your code more elegant:</p>
<ul>
<li>Arrays can be 1D, like lists, but they can also be 2D, like matrices, and higher-dimensional still. This allows them to represent many different kinds of numerical data. In our case, we are manipulating a 2D matrix.</li>
<li>Arrays can be operated on along <em>axes</em>. In the first line, we calculate the
sum down each column by specifying <code>axis=0</code>.</li>
<li>Arrays allow the expression of many numerical operations at once.
For example toward the end of the function we divide the 2D array of counts (C) by the 1D array of column sums (N).
This is broadcasting. More on how this works in just a moment!</li>
</ul>
<p>Before we delve into the power of NumPy, let's spend some time looking at the biological data that we will be working with.</p>
<h2 id="Introduction-to-the-Data:-What-Is-Gene-Expression?">Introduction to the Data: What Is Gene Expression?<a class="anchor-link" href="#Introduction-to-the-Data:-What-Is-Gene-Expression?"> </a></h2><p>We will work our way through a <em>gene expression analysis</em> to demonstrate the power of NumPy and SciPy to solve a real-world biological problem.
We will use the pandas library, which builds on NumPy, to read and munge our data files, and then we will manipulate our data efficiently in NumPy arrays.</p>
<p>The so-called <a href="https://en.wikipedia.org/wiki/Central_dogma_of_molecular_biology">central dogma of molecular biology</a> states that all the information needed to run a cell (or an organism, for that matter) is stored in a molecule called <em>deoxyribonucleic acid</em>, or DNA.
This molecule has a repetitive backbone on which lie chemical groups called <em>bases</em>, in sequence.
There are four kinds of bases, abbreviated as A, C, G, and T, comprising an alphabet with which information is stored.</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e4/DNA_chemical_structure.svg"/>
<!-- caption text="The chemical structure of DNA (image by Madeleine Price Ball, used under the terms of the CC0 public domain license)" --></p>
<p>To access this information, the DNA is <em>transcribed</em> into a sister molecule called <em>messenger ribonucleic acid</em>, or mRNA.
Finally, this mRNA is <em>translated</em> into proteins, the workhorses of the cell.
A section of DNA that encodes the information to make a protein (via mRNA) is called a gene.</p>
<p>The amount of mRNA produced from a given gene is called the <em>expression</em> of that gene.
Although we would ideally like to measure protein levels, this is a much harder task than measuring mRNA.
Fortunately, expression levels of an mRNA and levels of its corresponding protein are usually correlated.<sup class="footnote-ref" id="fnref-maier"><a href="#fn-maier">1</a></sup></p>
<p>Therefore, we usually measure mRNA levels and base our analyses on that.
As you will see below, it often doesn't matter, because we are using mRNA levels for their power to predict biological outcomes, rather than to make specific statements about proteins.</p>
<p><img src="../figures/central_dogma.png"/>
<!-- caption text="Central dogma of molecular biology" --></p>
<p>It's important to note that the DNA in every cell of your body is identical.
Thus, the differences between cells arise from <em>differential expression</em> of
that DNA into RNA: in different cells, different parts of the DNA are processed
into downstream molecules. Similarly, as we will see in this chapter and the
next, differential expression can distinguish different kinds of cancer.</p>
<p><img src="../figures/differential_gene_expression.png"/>
<!-- caption text="Gene expression" --></p>
<p>The state-of-the-art technology to measure mRNA is RNA sequencing (RNAseq).
RNA is extracted from a tissue sample (e.g., from a biopsy from a patient), <em>reverse transcribed</em> back into DNA (which is more stable), and then read out using chemically modified bases that glow when they are incorporated into the DNA sequence.
Currently, high-throughput sequencing machines can only read short fragments (approximately 100 bases is common). These short sequences are called “reads.”
We measure millions of reads and then based on their sequence we count how many reads came from each gene.
We’ll be starting our analysis directly from this count data.</p>
<p><img src="../figures/RNAseq.png"/>
<!-- caption text="RNA sequencing (RNAseq)" --></p>
<p>This table shows a minimal example of gene expression count data:</p>
<table>
<thead><tr>
<th></th>
<th>Cell type A</th>
<th>Cell type B</th>
</tr>
</thead>
<tbody>
<tr>
<td>Gene 0</td>
<td>100</td>
<td>200</td>
</tr>
<tr>
<td>Gene 1</td>
<td>50</td>
<td>0</td>
</tr>
<tr>
<td>Gene 2</td>
<td>350</td>
<td>100</td>
</tr>
</tbody>
</table>
<p>The data is a table of counts, integers representing how many reads were observed for each gene in each cell type.
See how the counts for each gene differ between the cell types?
We can use this information to learn about the differences between these two types of cell.</p>
<p>One way to represent this data in Python would be as a list of lists:</p>
<div class="footnotes">
<hr>
<ol><li id="fn-maier"><p>Tobias Maier, Marc Güell, and Luis Serrano. <a href="http://www.sciencedirect.com/science/article/pii/S0014579309008126">"Correlation of mRNA and protein in complex biological samples"</a>, FEBS Letters 583, no. 204 (2009).<a href="#fnref-maier" class="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">gene0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">]</span>
<span class="n">gene1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="n">gene2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">350</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">expression_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">gene0</span><span class="p">,</span> <span class="n">gene1</span><span class="p">,</span> <span class="n">gene2</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Above, each gene's expression across different cell types is stored in a list of Python integers.
Then, we store all of these lists in a list (a meta-list, if you will).
We can retrieve individual data points using two levels of list indexing:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">expression_data</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>350</pre>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Because of the way the Python interpreter works, this is a very inefficient way to store these data points.
First, Python lists are always lists of <em>objects</em>, so that the above list <code>gene2</code> is not a list of integers, but a list of <em>pointers</em> to integers, which is unnecessary overhead.
Additionally, this means that each of these lists and each of these integers ends up in a completely different, random part of your computer's RAM.
However, modern processors actually like to retrieve things from memory in <em>chunks</em>, so this spreading of the data throughout the RAM is inefficient.</p>
<p>This is precisely the problem solved by the <em>NumPy array</em>.</p>
<h2 id="NumPy-N-Dimensional-Arrays">NumPy N-Dimensional Arrays<a class="anchor-link" href="#NumPy-N-Dimensional-Arrays"> </a></h2><p>One of the key NumPy data types is the N-dimensional array (ndarray, or just array).
Ndarrays underpin lots of awesome data manipulation techniques in SciPy.
In particular, we're going to explore vectorization and broadcasting,
techniques that allow us to write powerful, elegant code to manipulate our data.</p>
<p>First, let's get our heads around the the ndarray.
These arrays must be homogeneous: all items in an array must be the same type.
In our case we will need to store integers.
Ndarrays are called N-dimensional because they can have any number of dimensions.
A 1-dimensional array is roughly equivalent to a Python list:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">array1d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">array1d</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">array1d</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[1 2 3 4]
&lt;class &#39;numpy.ndarray&#39;&gt;
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Arrays have particular attributes and methods, that you can access by placing a dot after the array name.
For example, you can get the array's <em>shape</em> with the following code:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">array1d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(4,)
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here, it's just a tuple with a single number.
You might wonder why you wouldn't just use <code>len</code>, as you would for a list.
That will work, but it doesn't extend to <em>2D</em> arrays.</p>
<p>This is what we use to represent the data in the table above:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">array2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">expression_data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">array2d</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">array2d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">array2d</span><span class="p">))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[[100 200]
 [ 50   0]
 [350 100]]
(3, 2)
&lt;class &#39;numpy.ndarray&#39;&gt;
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now you can see that the <code>shape</code> attribute generalizes <code>len</code> to account for the size of multiple dimensions of an array of data.</p>
<p><img src="../figures/NumPy_ndarrays_v2.png"/>
<!-- caption text="Visualizing NumPy's ndarrays in one, two and three dimensions" --></p>
<p>Arrays have other attributes, such as <code>ndim</code>, the number of dimensions:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">array2d</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>2
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You'll become familiar with all of these as you start to use NumPy more for your own data analysis.</p>
<p>NumPy arrays can represent data that has even more dimensions, such as magnetic resonance imaging (MRI) data, which includes measurements within a 3D volume.
If we store MRI values over time, we might need a 4D NumPy array.</p>
<p>For now, we'll stick to 2D data.
Later chapters will introduce higher-dimensional data and will teach you to write code that works for data of any number of dimensions.</p>
<h3 id="Why-Use-ndarrays-Instead-of-Python-Lists?">Why Use ndarrays Instead of Python Lists?<a class="anchor-link" href="#Why-Use-ndarrays-Instead-of-Python-Lists?"> </a></h3><p>Arrays are fast because they enable vectorized operations, written in the low-level language C, that act on the whole array.
Say you have a list and you want to multiply every element in the list by five.
A standard Python approach would be to write a loop that iterates over the
elements of the list and multiply each one by five.
However, if your data were instead represented as an array,
you can multiply every element in the array by five in a single bound.
Behind the scenes, the highly-optimized NumPy library is doing the iteration as fast as possible.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># Create an ndarray of integers in the range</span>
<span class="c1"># 0 up to (but not including) 1,000,000</span>
<span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">1e6</span><span class="p">)</span>

<span class="c1"># Convert it to a list</span>
<span class="n">list_array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's compare how long it takes to multiply all the values in the array by five,
using the IPython <code>timeit</code> magic function. First, when the data is in a list:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">timeit</span> -n10 y = [val * 5 for val in list_array]
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>56.6 ms ± 2.2 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, using NumPy's built-in <em>vectorized</em> operations:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">timeit</span> -n10 x = array * 5
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>986 µs ± 462 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Over 50 times faster, and more concise, too!</p>
<p>Arrays are also size efficient.
In Python, each element in a list is an object and is given a healthy memory allocation (or is that unhealthy?).
In contrast, in arrays, each element takes up just the necessary amount of memory.
For example, an array of 64-bit integers takes up exactly 64-bits per element, plus some very small overhead for array metadata, such as the <code>shape</code> attribute we discussed above.
This is generally much less than would be given to objects in a Python list.
(If you're interested in digging into how Python memory allocation works, check out Jake VanderPlas's blog post, <a href="https://jakevdp.github.io/blog/2014/05/09/why-python-is-slow/">"Why Python Is Slow: Looking Under the Hood"</a>.)</p>
<p>Plus, when computing with arrays, you can also use <em>slices</em> that subset the array <em>without copying the underlying data</em>.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Create an ndarray x</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[1 2 3]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Create a &quot;slice&quot; of x</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[1 2]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Set the first element of y to be 6</span>
<span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">6</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[6 2]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Notice that although we edited <code>y</code>, <code>x</code> has also changed, because <code>y</code> was referencing the same data!</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Now the first element in x has changed to 6!</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[6 2 3]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This means you have to be careful with array references.
If you want to manipulate the data without touching the original, it's easy to make a copy:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Vectorization">Vectorization<a class="anchor-link" href="#Vectorization"> </a></h3><p>Earlier we talked about the speed of operations on arrays.
One of the tricks NumPy uses to speed things up is <em>vectorization</em>.
Vectorization is where you apply a calculation to each element in an array, without having to use a for loop.
In addition to speeding things up, this can result in more natural, readable code.
Let's look at some examples.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[2 4 6 8]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here, we have <code>x</code>, an array of 4 values, and we have implicitly multiplied every element in <code>x</code> by 2, a single value.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[1 3 5 5]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now, we have added together each element in <code>x</code> to its corresponding element in <code>y</code>, an array of the same shape.</p>
<p>Both of these operations are simple and, we hope, intuitive examples of vectorization.
NumPy also makes them very fast, much faster than iterating over the arrays manually.
(Feel free to play with this yourself using the <code>%timeit</code> IPython magic we saw earlier.)</p>
<h3 id="Broadcasting">Broadcasting<a class="anchor-link" href="#Broadcasting"> </a></h3><p>One of the most powerful and often misunderstood features of ndarrays is broadcasting.
Broadcasting is a way of performing implicit operations between two arrays.
It allows you to perform operations on arrays of <em>compatible</em> shapes, to create arrays bigger than either of the starting ones.
For example, we can compute the <a href="https://en.wikipedia.org/wiki/Outer_product">outer product</a> of two vectors, by reshaping them appropriately:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[[1]
 [2]
 [3]
 [4]]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[[0 1 2 1]]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Two shapes are compatible when, for each dimension, either is equal to
1 (one) or they match one another<sup class="footnote-ref" id="fnref-more_dimensions"><a href="#fn-more_dimensions">1</a></sup>.</p>
<p>Let's check the shapes of these two arrays.</p>
<div class="footnotes">
<hr>
<ol><li id="fn-more_dimensions"><p>We always start by comparing the last dimensions,
and work our way forward, ignoring excess
dimensions in the case of one array having more
than the other (e.g., <code>(3, 5, 1)</code> and <code>(5, 8)</code>
would match.<a href="#fnref-more_dimensions" class="footnote">&#8617;</a></p></li>
</ol>
</div>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(4, 1)
(1, 4)
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Both arrays have two dimensions and the inner dimensions of both arrays are 1, so the dimensions are compatible!</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">outer</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
<span class="nb">print</span><span class="p">(</span><span class="n">outer</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[[0 1 2 1]
 [0 2 4 2]
 [0 3 6 3]
 [0 4 8 4]]
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The outer dimensions tell you the size of the resulting array.
In our case we expect a (4, 4) array:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">outer</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(4, 4)
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You can see for yourself that <code>outer[i, j] = x[i] * y[j]</code> for all <code>(i, j)</code>.</p>
<p>This was accomplished by NumPy's <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">broadcasting rules</a>, which implicitly expand dimensions of size 1 in one array to match the corresponding dimension of the other array.
Don't worry, we will talk about these rules in more detail later in this chapter.</p>
<p>As we will see in the rest of the chapter, as we explore real data, broadcasting is extremely valuable for real-world calculations on arrays of data.
It allows us to express complex operations concisely and efficiently.</p>
<h2 id="Exploring-a-Gene-Expression-Dataset">Exploring a Gene Expression Dataset<a class="anchor-link" href="#Exploring-a-Gene-Expression-Dataset"> </a></h2><p>The dataset that we'll be using is an RNAseq experiment of skin cancer samples from The Cancer Genome Atlas (TCGA) project (<a href="http://cancergenome.nih.gov/">http://cancergenome.nih.gov/</a>).
We've already cleaned and sorted the data for you, so you can use <code>data/counts.txt.bz2</code>
in the book repository.
In Chapter 2 we will be using this gene expression data to predict mortality in skin cancer patients, reproducing a simplified version of <a href="http://www.cell.com/action/showImagesData?pii=S0092-8674%2815%2900634-0">Figures 5A and 5B</a> of a <a href="http://dx.doi.org/10.1016/j.cell.2015.05.044">paper</a> from the TCGA consortium.
But first we need to get our heads around the biases in our data, and think about how we could improve it.</p>
<h3 id="Reading-in-the-Data-with-pandas">Reading in the Data with pandas<a class="anchor-link" href="#Reading-in-the-Data-with-pandas"> </a></h3><p>We're first going to use pandas to read in the table of counts.
pandas is a Python library for data manipulation and analysis,
with particular emphasis on tabular and time series data.
Here, we will use it here to read in tabular data of mixed type.
It uses the <code>DataFrame</code> type, which is a flexible tabular format based on the data frame object in R.
For example, the data we will read has a column of gene names (strings) and multiple columns of counts (integers), so reading it into a homogeneous array of numbers would be the wrong approach.
Although NumPy has some support for mixed data types (called "structured arrays"), it is not primarily designed for
this use case, which makes subsequent operations harder than they need to be.</p>
<p>By reading the data in as a pandas data frame, we can let pandas do all the parsing, then extract out the relevant information and store it in a more efficient data type.
Here we are just using pandas briefly to import data.
In later chapters we will see a bit more of pandas, but for details, read <em>Python
for Data Analysis</em> (O'Reilly) by the creator of pandas, Wes McKinney.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">bz2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="c1"># Import TCGA melanoma data</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;data/counts.txt.bz2&#39;</span>
<span class="k">with</span> <span class="n">bz2</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">data_table</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># Parse file with pandas</span>

<span class="nb">print</span><span class="p">(</span><span class="n">data_table</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:</span><span class="mi">5</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>       00624286-41dd-476f-a63b-d2a5f484bb45  TCGA-FS-A1Z0  TCGA-D9-A3Z1  \
A1BG                                1272.36        452.96        288.06   
A1CF                                   0.00          0.00          0.00   
A2BP1                                  0.00          0.00          0.00   
A2LD1                                164.38        552.43        201.83   
A2ML1                                 27.00          0.00          0.00   

       02c76d24-f1d2-4029-95b4-8be3bda8fdbe  TCGA-EB-A51B  
A1BG                                 400.11        420.46  
A1CF                                   1.00          0.00  
A2BP1                                  0.00          1.00  
A2LD1                                165.12         95.75  
A2ML1                                  0.00          8.00  
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can see that pandas has kindly pulled out the header row and used it to name the columns.
The first column gives the name of each gene, and the remaining columns represent individual samples.</p>
<p>We will also need some corresponding metadata, including the sample information and the gene lengths.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Sample names</span>
<span class="n">samples</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">data_table</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We will need some information about the lengths of the genes for our normalization.
So that we can take advantage of some fancy pandas indexing, we're going to set
the index of the pandas table to be the gene names in the first column.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Import gene lengths</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;data/genes.csv&#39;</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;rt&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># Parse file with pandas, index by GeneSymbol</span>
    <span class="n">gene_info</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">index_col</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gene_info</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:</span><span class="mi">5</span><span class="p">,</span> <span class="p">:])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>            GeneID  GeneLength
GeneSymbol                    
CPA1          1357        1724
GUCY2D        3000        3623
UBC           7316        2687
C11orf95     65998        5581
ANKMY2       57037        2611
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's check how well our gene length data matches up with our count data.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Genes in data_table: &quot;</span><span class="p">,</span> <span class="n">data_table</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Genes in gene_info: &quot;</span><span class="p">,</span> <span class="n">gene_info</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Genes in data_table:  20500
Genes in gene_info:  20503
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>There are more genes in our gene length data than were actually measured in the experiment.
Let's filter so we only get the relevant genes, and we want to make sure they are
in the same order as in our count data.
This is where pandas indexing comes in handy!
We can get the intersection of the gene names from our two sources of data
and use these to index both datasets, ensuring they have the same genes in the same order.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Subset gene info to match the count data</span>
<span class="n">matched_index</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">data_table</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">gene_info</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now let's use the intersection of the gene names to index our count data.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 2D ndarray containing expression counts for each gene in each individual</span>
<span class="n">counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data_table</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">matched_index</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<span class="n">gene_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">matched_index</span><span class="p">)</span>

<span class="c1"># Check how many genes and individuals were measured</span>
<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{counts.shape[0]}</span><span class="s1"> genes measured in </span><span class="si">{counts.shape[1]}</span><span class="s1"> individuals.&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>20500 genes measured in 375 individuals.
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And our gene lengths.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># 1D ndarray containing the lengths of each gene</span>
<span class="n">gene_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">gene_info</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">matched_index</span><span class="p">][</span><span class="s1">&#39;GeneLength&#39;</span><span class="p">],</span>
                          <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And let's check the dimensions of our objects.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">gene_lengths</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(20500, 375)
(20500,)
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>As expected, they now match up nicely!</p>
<h2 id="Normalization">Normalization<a class="anchor-link" href="#Normalization"> </a></h2><p>Real world data contains all kinds of measurement artifacts.
Before doing any kind of analysis with it, it is important to take a look at
it to determine whether some normalization is warranted.
For example, measurements with digital thermometers may systematically vary from
those taken with mercury thermometers and read out by a human.
Thus, comparing samples often requires some kind of data wrangling to bring
every measurement to a common scale.</p>
<p>In our case, we want to make sure that any differences we uncover correspond to
real biological differences, and not to technical artifact.
We will consider two levels of normalization often applied jointly to gene
expression dataset: normalization between samples (columns) and normalization
between genes (rows).</p>
<h3 id="Between-Samples">Between Samples<a class="anchor-link" href="#Between-Samples"> </a></h3><p>For example, the number of counts for each individual can vary substantially in RNAseq experiments.
Let's take a look at the distribution of expression counts over all the genes.
First, we will sum the columns to get the total counts of expression of all genes for each individual, so we can just look at the variation between individuals.
To visualize the distribution of total counts, we will use kernel density
estimation (KDE), a technique commonly used to smooth out histograms because it
gives a clearer picture of the underlying distribution.</p>
<p>Before we start, we have to do some plotting setup (which we will do in every
chapter). See "A quick note on plotting" for details about each line of the following code.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Make all plots appear inline in the Jupyter notebook from now onwards</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
<span class="c1"># Use our own style file for the plots</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;style/elegant.mplstyle&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote><p><strong>A Quick Note on Plotting {.callout}</strong></p>
<p>The preceding code does a few neat things to make our plots prettier.</p>
<p>First, <code>%matplotlib inline</code> is a Jupyter notebook <a href="http://ipython.org/ipython-doc/dev/interactive/tutorial.html#magics-explained">magic
command</a>,
that simply makes all plots appear in the notebook rather than pop up a new
window. If you are running a Jupyter notebook interactively, you can use
<code>%matplotlib notebook</code> instead to get an interactive figure, rather than a
static image of each plot.</p>
<p>Second, we import <code>matplotlib.pyplot</code> and then direct it to use our own plotting
style <code>plt.style.use('style/elegant.mplstyle')</code>. You will see a block of code
like this before the first plot in every chapter.</p>
<p>You may have seen people importing existing styles like this:
<code>plt.style.use('ggplot')</code>. But we wanted some particular settings, and we
wanted all the plots in this book to follow the same style. So we rolled our
own Matplotlib style. To see how we did it, take a look at the style file in
the Elegant SciPy repository: <code>style/elegant.mplstyle</code>. For more information
on styles, check out the <a href="http://matplotlib.org/users/style_sheets.html">Matplotlib documentation on style
sheets</a>.</p>
</blockquote>
<p>Now back to plotting our counts distribution!</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">total_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sum columns together</span>
                                       <span class="c1"># (axis=1 would sum rows)</span>

<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">stats</span>

<span class="c1"># Use Gaussian smoothing to estimate the density</span>
<span class="n">density</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kde</span><span class="o">.</span><span class="n">gaussian_kde</span><span class="p">(</span><span class="n">total_counts</span><span class="p">)</span>

<span class="c1"># Make values for which to estimate the density, for plotting</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">total_counts</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">total_counts</span><span class="p">),</span> <span class="mi">10000</span><span class="p">)</span>

<span class="c1"># Make the density plot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">density</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Total counts per individual&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Density&quot;</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="s1">&#39;Count statistics:</span><span class="se">\n</span><span class="s1">  min:  {np.min(total_counts)}&#39;</span>
      <span class="n">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">  mean: {np.mean(total_counts)}&#39;</span>
      <span class="n">f</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">  max:  {np.max(total_counts)}&#39;</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/ch1_60_0.png"
>
</div>

</div>
</div>
<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Count statistics:
  min:  6231205
  mean: 52995255.33866667
  max:  103219262
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<!-- caption text="Density plot of gene expression counts per individual using KDE smoothing" -->

<p>We can see that there is an order of magnitude difference in the total number of counts between the lowest and the highest individual.
This means that a different number of RNAseq reads were generated for each individual.
We say that these individuals have different library sizes.</p>
<h4 id="Normalizing-library-size-between-samples">Normalizing library size between samples<a class="anchor-link" href="#Normalizing-library-size-between-samples"> </a></h4><p>Let's take a closer look at ranges of gene expression for each individual, so when
we apply our normalization we can see it in action. We'll subset a random sample
of just 70 columns to keep the plotting from getting too messy.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Subset data for plotting</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span> <span class="c1"># Set seed so we will get consistent results</span>
<span class="c1"># Randomly select 70 samples</span>
<span class="n">samples_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">size</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">counts_subset</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[:,</span> <span class="n">samples_index</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Some custom x-axis labelling to make our plots easier to read</span>
<span class="k">def</span> <span class="nf">reduce_xaxis_labels</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Show only every ith label to prevent crowding on x-axis</span>
<span class="sd">        e.g. factor = 2 would plot every second x-axis label,</span>
<span class="sd">        starting at the first.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ax : matplotlib plot axis to be adjusted</span>
<span class="sd">    factor : int, factor to reduce the number of x-axis labels by</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_ticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">get_ticklabels</span><span class="p">()[</span><span class="n">factor</span><span class="o">-</span><span class="mi">1</span><span class="p">::</span><span class="n">factor</span><span class="p">]:</span>
        <span class="n">label</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Box plot of expression counts by individual</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">4.8</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">))</span>

<span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="s1">&#39;style/thinner.mplstyle&#39;</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">counts_subset</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Individuals&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;Gene expression counts&quot;</span><span class="p">)</span>
    <span class="n">reduce_xaxis_labels</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/ch1_64_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<!-- caption text="Boxplot of gene expression counts per individual" -->

<p>There are obviously a lot of outliers at the high expression end of the scale and a lot of variation between individuals, but these are hard to see because everything is clustered around zero.
So let's do log(n + 1) of our data so it's a bit easier to look at.
Both the log function and the n + 1 step can be done using broadcasting to simplify our code and speed things up.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Bar plot of expression counts by individual</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">4.8</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">))</span>

<span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="s1">&#39;style/thinner.mplstyle&#39;</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts_subset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Individuals&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;log gene expression counts&quot;</span><span class="p">)</span>
    <span class="n">reduce_xaxis_labels</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/ch1_66_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<!-- caption text="Boxplot of gene expression counts per individual (log scale)" -->

<p>Now let's see what happens when we normalize by library size.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Normalize by library size</span>
<span class="c1"># Divide the expression counts by the total counts for that individual</span>
<span class="c1"># Multiply by 1 million to get things back in a similar scale</span>
<span class="n">counts_lib_norm</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">/</span> <span class="n">total_counts</span> <span class="o">*</span> <span class="mi">1000000</span>
<span class="c1"># Notice how we just used broadcasting twice there!</span>
<span class="n">counts_subset_lib_norm</span> <span class="o">=</span> <span class="n">counts_lib_norm</span><span class="p">[:,</span><span class="n">samples_index</span><span class="p">]</span>

<span class="c1"># Bar plot of expression counts by individual</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">4.8</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">))</span>

<span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="s1">&#39;style/thinner.mplstyle&#39;</span><span class="p">):</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts_subset_lib_norm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Individuals&quot;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;log gene expression counts&quot;</span><span class="p">)</span>
    <span class="n">reduce_xaxis_labels</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/ch1_68_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<!-- caption text="Boxplot of library-normalized gene expression counts per individual (log scale)" -->

<p>Much better!
Also notice how we used broadcasting twice there.
Once to divide all the gene expression counts by the total for that column, and then again to multiply all the values by 1 million.</p>
<p>Finally, let's compare our normalized data to the raw data.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">defaultdict</span>


<span class="k">def</span> <span class="nf">class_boxplot</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">classes</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Make a boxplot with boxes colored according to the class they belong to.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : list of array-like of float</span>
<span class="sd">        The input data. One boxplot will be generated for each element</span>
<span class="sd">        in `data`.</span>
<span class="sd">    classes : list of string, same length as `data`</span>
<span class="sd">        The class each distribution in `data` belongs to.</span>

<span class="sd">    Other parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    kwargs : dict</span>
<span class="sd">        Keyword arguments to pass on to `plt.boxplot`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_classes</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">classes</span><span class="p">))</span>
    <span class="n">colors</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.prop_cycle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">by_key</span><span class="p">()[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span>
    <span class="n">class2color</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">all_classes</span><span class="p">,</span> <span class="n">it</span><span class="o">.</span><span class="n">cycle</span><span class="p">(</span><span class="n">colors</span><span class="p">)))</span>

    <span class="c1"># map classes to data vectors</span>
    <span class="c1"># other classes get an empty list at that position for offset</span>
    <span class="n">class2data</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">distrib</span><span class="p">,</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">classes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">all_classes</span><span class="p">:</span>
            <span class="n">class2data</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">class2data</span><span class="p">[</span><span class="bp">cls</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">distrib</span>

    <span class="c1"># then, do each boxplot in turn with the appropriate color</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">all_classes</span><span class="p">:</span>
        <span class="c1"># set color for all elements of the boxplot</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;boxprops&#39;</span><span class="p">,</span> <span class="s1">&#39;whiskerprops&#39;</span><span class="p">,</span> <span class="s1">&#39;flierprops&#39;</span><span class="p">]:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">{})</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">color</span><span class="o">=</span><span class="n">class2color</span><span class="p">[</span><span class="bp">cls</span><span class="p">])</span>
        <span class="c1"># draw the boxplot</span>
        <span class="n">box</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">class2data</span><span class="p">[</span><span class="bp">cls</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">box</span><span class="p">[</span><span class="s1">&#39;whiskers&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">all_classes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ax</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now we can plot a colored boxplot according to normalized versus unnormalized samples.
We show only three samples from each class for illustration:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">log_counts_3</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">log_ncounts_3</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts_lib_norm</span><span class="o">.</span><span class="n">T</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">class_boxplot</span><span class="p">(</span><span class="n">log_counts_3</span> <span class="o">+</span> <span class="n">log_ncounts_3</span><span class="p">,</span>
                   <span class="p">[</span><span class="s1">&#39;raw counts&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">+</span> <span class="p">[</span><span class="s1">&#39;normalized by library size&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
                   <span class="n">labels</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;sample number&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;log gene expression counts&#39;</span><span class="p">);</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/ch1_72_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<!-- caption text="Comparing raw and library normalized gene expression counts in three samples (log scale)" -->

<p>You can see that the normalized distributions are a little more similar
when we take library size (the sum of those distributions) into account.
Now we are comparing like with like between the samples!
But what about differences between the genes?</p>
<h3 id="Between-Genes">Between Genes<a class="anchor-link" href="#Between-Genes"> </a></h3><p>We can also get into some trouble when trying to compare different genes.
The number of counts for a gene is related to the gene length.
Suppose gene B is twice as long as gene A.
Both are expressed at similar levels in the sample (i.e., both produce a similar number of mRNA molecules).
Remember that in RNAseq experiment, we fragment the transcripts, and sample reads from that pool of fragments.
So if a gene is twice as long, it'll produce twice as many fragments, and we are twice as likely to sample it.
Therefore, we would expect gene B to have about twice as many counts as gene A.
If we want to compare the expression levels of different genes, we will have to do some more normalization.</p>
<p><img src="../figures/gene_length_counts.png"/>
<!-- caption text="Relationship between counts and gene length" --></p>
<p>Let's see if the relationship between gene length and counts plays out in our dataset.
First, we define a utility function for plotting:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">binned_boxplot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>  <span class="c1"># check out this Python 3 exclusive! (*see tip box)</span>
                   <span class="n">xlabel</span><span class="o">=</span><span class="s1">&#39;gene length (log scale)&#39;</span><span class="p">,</span>
                   <span class="n">ylabel</span><span class="o">=</span><span class="s1">&#39;average log counts&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plot the distribution of `y` dependent on `x` using many boxplots.</span>

<span class="sd">    Note: all inputs are expected to be log-scaled.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: 1D array of float</span>
<span class="sd">        Independent variable values.</span>
<span class="sd">    y: 1D array of float</span>
<span class="sd">        Dependent variable values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define bins of `x` depending on density of observations</span>
    <span class="n">x_hist</span><span class="p">,</span> <span class="n">x_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>

    <span class="c1"># Use `np.digitize` to number the bins</span>
    <span class="c1"># Discard the last bin edge because it breaks the right-open assumption</span>
    <span class="c1"># of `digitize`. The max observation correctly goes into the last bin.</span>
    <span class="n">x_bin_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x_bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Use those indices to create a list of arrays, each containing the `y`</span>
    <span class="c1"># values corresponding to `x`s in that bin. This is the input format</span>
    <span class="c1"># expected by `plt.boxplot`</span>
    <span class="n">binned_y</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="n">x_bin_idxs</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x_bin_idxs</span><span class="p">))]</span>
    <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mf">4.8</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Make the x-axis labels using the bin centers</span>
    <span class="n">x_bin_centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">x_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">x_bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">x_ticklabels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x_bin_centers</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="c1"># make the boxplot</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">boxplot</span><span class="p">(</span><span class="n">binned_y</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">x_ticklabels</span><span class="p">)</span>

    <span class="c1"># show only every 10th label to prevent crowding on x-axis</span>
    <span class="n">reduce_xaxis_labels</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="c1"># Adjust the axis names</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">xlabel</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">ylabel</span><span class="p">);</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote><p><strong>Python 3 Tip: using <code>*</code> to create keyword-only arguments {.callout}</strong></p>
<p>Since version 3.0 Python allows
<a href="https://www.python.org/dev/peps/pep-3102/">"keyword-only" arguments</a>.
These are arguments that you have to call using a keyword, rather than relying
on position alone.
For example, you can call the <code>binned_boxplot</code> we just wrote like so:</p>

<pre><code>&gt;&gt;&gt; binned_boxplot(x, y, xlabel='my x label', ylabel='my y label')

</code></pre>
<p>but not this, which would have been valid Python 2, but raises an error in
Python 3:</p>

<pre><code>&gt;&gt;&gt; binned_boxplot(x, y, 'my x label', 'my y label')

---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-58-7a118d2d5750in &lt;module&gt;()
    1 x_vals = [1, 2, 3, 4, 5]
    2 y_vals = [1, 2, 3, 4, 5]
----3 binned_boxplot(x, y, 'my x label', 'my y label')

TypeError: binned_boxplot() takes 2 positional arguments but 4 were given

</code></pre>
<p>The idea is to prevent you from accidentally doing something like this:</p>

<pre><code>binned_boxplot(x, y, 'my y label')

</code></pre>
<p>which would give you your y label on the x-axis, and is a common error for
signatures with many optional parameters that don't have an obvious ordering.</p>
</blockquote>
<p>We now compute the gene lengths and counts:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">log_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts_lib_norm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">mean_log_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">log_counts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># across samples</span>
<span class="n">log_gene_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gene_lengths</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And we plot the counts as a function of gene length:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="s1">&#39;style/thinner.mplstyle&#39;</span><span class="p">):</span>
    <span class="n">binned_boxplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">log_gene_lengths</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">mean_log_counts</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/ch1_78_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can see in the previous image that the longer a gene is, the higher its measured counts! As
previously explained, this is an artifact of the technique, not a biological signal!
How do we account for this?</p>
<h3 id="Normalizing-Over-Samples-and-Genes:-RPKM">Normalizing Over Samples and Genes: RPKM<a class="anchor-link" href="#Normalizing-Over-Samples-and-Genes:-RPKM"> </a></h3><p>One of the simplest normalization methods for RNAseq data is RPKM: reads per
kilobase transcript per million reads.
RPKM puts together the ideas of normalizing by sample and by gene.
When we calculate RPKM, we are normalizing for both the library size (the sum of each column)
and the gene length.</p>
<p>To work through how RPKM is derived, let's define the following values:</p>
<ul>
<li>$C$ = Number of reads mapped to a gene</li>
<li>$L$ = Exon length in base-pairs for a gene</li>
<li>$N$ = Total mapped reads in the experiment</li>
</ul>
<p>First, let's calculate reads per kilobase.</p>
<p>Reads per base would be:
$\frac{C}{L}$</p>
<p>The formula asks for reads per kilobase instead of reads per base.
One kilobase = 1,000 bases, so we'll need to divide length (L) by 1,000.</p>
<p>Reads per kilobase would be:</p>
<p>$\frac{C}{L/1000}  = \frac{10^3C}{L}$</p>
<p>Next, we need to normalize by library size.
If we just divide by the number of mapped reads we get:</p>
<p>$ \frac{10^3C}{LN} $</p>
<p>But biologists like thinking in millions of reads so that the numbers don't get
too small. Counting per million reads we get:</p>
<p>$ \frac{10^3C}{L(N/10^6)} = \frac{10^9C}{LN}$</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In summary, to calculate reads per kilobase transcript per million reads:
$RPKM = \frac{10^9C}{LN}$</p>
<p>Now let's implement RPKM over the entire counts array.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Make our variable names the same as the RPKM formula so we can compare easily</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">counts</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sum each column to get total reads per sample</span>
<span class="n">L</span> <span class="o">=</span> <span class="n">gene_lengths</span>  <span class="c1"># lengths for each gene, matching rows in `C`</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<blockquote><p><strong>Tip: Numbers and computers {.callout}</strong></p>
<p>We can't cover everything you need to know about numeric representations
in computers in just a tip box, but you <em>should</em> know that numbers are
represented as "n-bit" "integer" or "floating point" numbers in
the computer. As an example, a 32-bit precision integer is an integer
number (no decimal point) represented as a string of 0s and 1s of width</p>
<ol>
<li>And, just like you can't represent a number larger than 9999 ($10^4-1$)
if you have a length-4 array of numbers, you can't represent a number
larger than $2^32 - 1 \approx 4 \times 10^9$ if you are using 32-bit
integers, or $2^31 - 1 \approx 2 \times 10^9$ if you want to have negative
numbers (because you need one of the 32 bits to indicate sign).</li>
</ol>
<p>So what happens when you go over that limit? You can try it with the
following code:</p>

<pre><code>&gt;&gt;&gt; 2**31 - 1
2147483647
&gt;&gt;&gt; np.array([2147483647], dtype=np.int32) + 1
array([-2147483648], dtype=int32)

</code></pre>
<p>As you can see, it just ticks over, without warning!</p>
<p>Floating point numbers can express much larger numbers, at the cost of some
precision:</p>

<pre><code>&gt;&gt;&gt; np.float32(2**96)
7.9228163e+28
&gt;&gt;&gt; np.float32(2**96) == np.float32(2**96 + 1)
True

</code></pre>
<p>As mentioned, we can't go into all the subtleties of dealing with these
errors, but it's probably what we are avoiding if you see us converting an
array with <code>.astype(float)</code>!</p>
<p>The paper "What Every Computer Scientist Should Know About Floating-Point
Arithmetic", by David Goldberg, contains a lot of detail about this, if you
are curious. A free version is available at
<a href="https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html</a>
. Somewhat more amusingly, try:</p>

<pre><code>&gt;&gt;&gt; np.sum(np.array([0.1 + 0.2], dtype=np.float64))
0.30000000000000004

</code></pre>
<p>Then, copy that value to go to <a href="http://0.30000000000000004.com">http://0.30000000000000004.com</a>, which
contains a very concise explanation of the problem and links to further
resources, including the Goldberg paper.</p>
</blockquote>
<p>First, we multiply by $10^9$.
Because counts (C) is an ndarray, we can use broadcasting.
If we multiple an ndarray by a single value,
that value is broadcast over the entire array.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Multiply all counts by $10^9$. Note that ^ in Python is bitwise-or.</span>
<span class="c1"># Exponentiation is denoted by `**`</span>
<span class="c1"># Avoid overflow by converting C to float, see tip &quot;Numbers and computers&quot;</span>
<span class="n">C_tmp</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="mi">9</span> <span class="o">*</span> <span class="n">C</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Next we need to divide by the gene length.
Broadcasting a single value over a 2D array was pretty clear.
We were just multiplying every element in the array by the value.
But what happens when we need to divide a 2D array by a 1D array?</p>
<h4 id="Broadcasting-rules">Broadcasting rules<a class="anchor-link" href="#Broadcasting-rules"> </a></h4><p>Broadcasting allows calculations between ndarrays that have different shapes.
Numpy uses broadcasting rules to make these manipulations a little easier.
When two arrays have the same number of dimensions,
broadcasting can occur if the sizes of each dimension match,
or one of them is equal to 1.
If arrays have different numbers of dimensions, then $(1,)$ is prepended to the
shorter array until the numbers match, and then the standard broadcasting rules
apply.</p>
<p>For example, suppose we have two ndarrays, A and B, with shapes $(5, 2)$ and
$(2,)$.
We define the product <code>A * B</code> using broadcasting.
B has fewer dimensions than A, so during the calculation,
a new dimension is prepended to B with value 1, so B's new shape is $(1, 2)$.
Finally, where B's shape doesn't match A's, it is <em>multiplied</em> by stacking enough
versions of B, giving the shape $(5, 2)$. This is done "virtually", without using
up any additional memory. At this point, the product is just an element-wise
multiplication, giving an output array of the same shape as A.</p>
<p>Now let's say we have another array, C, of shape $(2, 5)$. To multiply (or add) C 
to B, we might try to prepend $(1,)$ to the shape of B, but in that case, we still
end up with incompatible shapes: $(2, 5)$ and $(1, 2)$. If we want the arrays to
broadcast, we have to <em>ap</em>pend a dimension to B, manually. Then, we end up with
$(2, 5)$ and $(2, 1)$, and broadcasting can proceed.</p>
<p>In NumPy, we can explicitly add a new dimension to B using <code>np.newaxis</code>.
Let's see this in our normalization by RPKM.</p>
<p>Let's look at the dimensions of our arrays.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="s1">&#39;C_tmp.shape&#39;</span><span class="p">,</span> <span class="n">C_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;L.shape&#39;</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>C_tmp.shape (20500, 375)
L.shape (20500,)
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can see that <code>C_tmp</code> has two dimensions, while <code>L</code> has one.
So during broadcasting, an additional dimension will be prepended to <code>L</code>.
Then we will have:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">
C_tmp.shape (20500, 375)
L.shape (1, 20500)
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The dimensions won't match!
We want to broadcast L over the first dimension of <code>C_tmp</code>,
so we need to adjust the dimensions of L ourselves.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="c1"># append a dimension to L, with value 1</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;C_tmp.shape&#39;</span><span class="p">,</span> <span class="n">C_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;L.shape&#39;</span><span class="p">,</span> <span class="n">L</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>C_tmp.shape (20500, 375)
L.shape (20500, 1)
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now that our dimensions match or are equal to 1, we can broadcast.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Divide each row by the gene length for that gene (L)</span>
<span class="n">C_tmp</span> <span class="o">=</span> <span class="n">C_tmp</span> <span class="o">/</span> <span class="n">L</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Finally we need to normalize by the library size,
the total number of counts for that column.
Remember that we have already calculated $N$ with:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">
N = np.sum(counts, axis=0) # sum each column to get total reads per sample
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Check the shapes of C_tmp and N</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;C_tmp.shape&#39;</span><span class="p">,</span> <span class="n">C_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N.shape&#39;</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>C_tmp.shape (20500, 375)
N.shape (375,)
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Once we trigger broadcasting, an additional dimension will be
prepended to N:</p>
<p><code>N.shape (1, 375)</code></p>
<p>The dimensions will match so we don't have to do anything.
However, for readability, it can be useful to add the extra dimension to N anyway.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Divide each column by the total counts for that column (N)</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">N</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;C_tmp.shape&#39;</span><span class="p">,</span> <span class="n">C_tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;N.shape&#39;</span><span class="p">,</span> <span class="n">N</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>C_tmp.shape (20500, 375)
N.shape (1, 375)
</pre>
</div>
</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># Divide each column by the total counts for that column (N)</span>
<span class="n">rpkm_counts</span> <span class="o">=</span> <span class="n">C_tmp</span> <span class="o">/</span> <span class="n">N</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's put this in a function so we can reuse it.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">rpkm</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">lengths</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Calculate reads per kilobase transcript per million reads.</span>

<span class="sd">    RPKM = (10^9 * C) / (N * L)</span>

<span class="sd">    Where:</span>
<span class="sd">    C = Number of reads mapped to a gene</span>
<span class="sd">    N = Total mapped reads in the experiment</span>
<span class="sd">    L = Exon length in base pairs for a gene</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    counts: array, shape (N_genes, N_samples)</span>
<span class="sd">        RNAseq (or similar) count data where columns are individual samples</span>
<span class="sd">        and rows are genes.</span>
<span class="sd">    lengths: array, shape (N_genes,)</span>
<span class="sd">        Gene lengths in base pairs in the same order</span>
<span class="sd">        as the rows in counts.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    normed : array, shape (N_genes, N_samples)</span>
<span class="sd">        The RPKM normalized counts matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">C</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># use float to avoid overflow with `1e9 * C`</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># sum each column to get total reads per sample</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">lengths</span>

    <span class="n">normed</span> <span class="o">=</span> <span class="mf">1e9</span> <span class="o">*</span> <span class="n">C</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">L</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

    <span class="k">return</span><span class="p">(</span><span class="n">normed</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">counts_rpkm</span> <span class="o">=</span> <span class="n">rpkm</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="n">gene_lengths</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h4 id="RPKM-between-gene-normalization">RPKM between gene normalization<a class="anchor-link" href="#RPKM-between-gene-normalization"> </a></h4><p>Let's see the RPKM normalization's effect in action. First, as a reminder, here's
the distribution of mean log counts as a function of gene length:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">log_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">mean_log_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">log_counts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">log_gene_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gene_lengths</span><span class="p">)</span>

<span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="s1">&#39;style/thinner.mplstyle&#39;</span><span class="p">):</span>
    <span class="n">binned_boxplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">log_gene_lengths</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">mean_log_counts</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/ch1_102_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<!-- caption text="The relationship between gene length and average expression before RPKM normalization (log scale)" -->

<p>Now, the same plot with the RPKM-normalized values:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">log_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts_rpkm</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">mean_log_counts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">log_counts</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">log_gene_lengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gene_lengths</span><span class="p">)</span>

<span class="k">with</span> <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">context</span><span class="p">(</span><span class="s1">&#39;style/thinner.mplstyle&#39;</span><span class="p">):</span>
    <span class="n">binned_boxplot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">log_gene_lengths</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">mean_log_counts</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/ch1_104_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>You can see that the mean expression counts have flattened quite a bit,
especially for genes larger than about 3,000 base pairs.
(Smaller genes still appear to have low expression — these may be too small for
the statistical power of the RPKM method.)</p>
<p>RPKM normalization can be useful to compare the expression profile of different genes.
We've already seen that longer genes have higher counts, but this doesn't mean their expression level is actually higher.
Let's choose a short gene and a long gene and compare their counts before and after RPKM normalization to see what we mean.</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">gene_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">((</span><span class="n">gene_names</span> <span class="o">==</span> <span class="s1">&#39;RPL24&#39;</span><span class="p">)</span> <span class="o">|</span>
                       <span class="p">(</span><span class="n">gene_names</span> <span class="o">==</span> <span class="s1">&#39;TXNDC5&#39;</span><span class="p">))</span>
<span class="n">gene1</span><span class="p">,</span> <span class="n">gene2</span> <span class="o">=</span> <span class="n">gene_names</span><span class="p">[</span><span class="n">gene_idxs</span><span class="p">]</span>
<span class="n">len1</span><span class="p">,</span> <span class="n">len2</span> <span class="o">=</span> <span class="n">gene_lengths</span><span class="p">[</span><span class="n">gene_idxs</span><span class="p">]</span>
<span class="n">gene_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="s1">&#39;</span><span class="si">{gene1}</span><span class="s1">, </span><span class="si">{len1}</span><span class="s1">bp&#39;</span><span class="p">,</span> <span class="n">f</span><span class="s1">&#39;</span><span class="si">{gene2}</span><span class="s1">, </span><span class="si">{len2}</span><span class="s1">bp&#39;</span><span class="p">]</span>

<span class="n">log_counts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts</span><span class="p">[</span><span class="n">gene_idxs</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">log_ncounts</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">counts_rpkm</span><span class="p">[</span><span class="n">gene_idxs</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">class_boxplot</span><span class="p">(</span><span class="n">log_counts</span><span class="p">,</span>
                   <span class="p">[</span><span class="s1">&#39;raw counts&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
                   <span class="n">labels</span><span class="o">=</span><span class="n">gene_labels</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Genes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;log gene expression counts over all samples&#39;</span><span class="p">);</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/ch1_106_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<!-- caption text="Comparing expression of two genes before RPKM normalization" -->

<p>If we look just at the raw counts, it looks like the longer gene, TXNDC5, is expressed
slightly more than the shorter one, RPL24.
But, after RPKM normalization, a different picture emerges:</p>

</div>
</div>
</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ax</span> <span class="o">=</span> <span class="n">class_boxplot</span><span class="p">(</span><span class="n">log_ncounts</span><span class="p">,</span>
                   <span class="p">[</span><span class="s1">&#39;RPKM normalized&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span>
                   <span class="n">labels</span><span class="o">=</span><span class="n">gene_labels</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Genes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;log RPKM gene expression counts over all samples&#39;</span><span class="p">);</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="jb_output_wrapper }}">
<div class="output_area">



<div class="output_png output_subarea ">
<img src="images/ch1_108_0.png"
>
</div>

</div>
</div>
</div>
</div>

</div>
</div>

<div class="jb_cell">

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<!-- caption text="Comparing expression of two genes after RPKM normalization" -->

<p>Now it looks like RPL24 is actually expressed at a much higher level than TXNDC5.
This is because RPKM includes normalization for gene length, so we can now directly compare between genes of different lengths.</p>
<h2 id="Taking-Stock">Taking Stock<a class="anchor-link" href="#Taking-Stock"> </a></h2><p>So far we have done the following:</p>
<ul>
<li>Imported data using pandas</li>
<li>Become familiar with the key NumPy object class — the ndarray</li>
<li>Used the power of broadcasting to make our calculations more elegant.</li>
</ul>
<p>In Chapter 2 we will continue working with the same dataset, implementing a
more sophisticated normalization technique, then use clustering to make some
predictions about mortality in skin cancer patients.</p>

</div>
</div>
</div>
</div>

 


    </main>
    